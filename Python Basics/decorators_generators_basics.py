# PYTHON DECORATORS AND GENERATORS



# Decorators

# In Python, a decorator is a design pattern to extend the functionality of a function or method without modifying its code. 
# It is a callable object (a function, method, or class) that is used to modify another function or method by wrapping it in one or more layers of additional logic. 
# Decorators are applied to a function or method using the "@" symbol, followed by the name of the decorator. For example:
"""
@decorator_function
def my_function():
    # function code here
"""
# This is equivalent to:
"""
def my_function():
    # function code here
my_function = decorator_function(my_function)
"""
# Decorators can be used to add functionality such as logging, timing, or access control to a function or method.

# A decorator wraps a function and modifies its behaviour.
def new_decorator(func):

    def wrap_func():
        print("X")
        func()
        print("Y")

    return wrap_func

def func_needs_decorator():
    print("Z")

func_needs_decorator()
print("\n")

func_needs_decorator = new_decorator(func_needs_decorator)
func_needs_decorator()
print("\n")

# @ --> Decorator Symbol
@new_decorator
def f_needs_decorator():
    print("Z")

f_needs_decorator()



#Â Generator

# In Python, a generator is a special type of function that can be used to create an iterator. 
# A generator function is defined like a normal function, but instead of using the return statement, it uses the yield statement to return a value. 
# Each time the generator function is called, it will execute the code up to the next yield statement and then return the value of the expression following the yield statement. 
# When the generator function is called again, it will resume execution from where it left off and continue until the next yield statement.

# For example, consider the following generator function that generates the numbers from 0 to 9:
def my_generator():
    i = 0
    while i < 10:
        yield i
        i += 1

# You can call this generator function like this:
gen = my_generator()
print(next(gen)) # prints 0
print(next(gen)) # prints 1
print(next(gen)) # prints 2

# You can also use a for loop to iterate over the items generated by a generator function:
for i in my_generator():
    print(i)

# This will print the numbers from 0 to 9.

# The advantage of using generators is that they are more memory efficient than lists because they only generate the next item in the sequence on demand, 
# rather than creating a list with all the items in advance. This can be particularly useful when working with large data sets or infinite sequences.



# Iterators

# An iterator is an object that implements the __iter__() and __next__() methods and allows for a convenient and efficient way to access the elements of a collection one at a time, 
# without loading the entire collection into memory at once, by iterating over a series of values, such as the elements of a list or the characters in a string.

# An iterator is an object that can be iterated (looped) upon. An object which will return data, one element at a time. 
# They are used to represent a stream of data. In Python, an iterator is an object that implements the __iter__() and __next__() methods. 
# The __iter__() method returns the iterator object and the __next__() method returns the next element from the iterator. If there are no more elements, it should raise StopIteration.

# The iter() function can be used to create an iterator from an iterable object, such as a list or a tuple. For example:
my_list = [1, 2, 3]
it = iter(my_list)
print(next(it)) # prints 1
print(next(it)) # prints 2
print(next(it)) # prints 3

# You can also use the for loop to iterate over the elements of an iterable.
# The for loop will automatically create an iterator and call the __next__() method until StopIteration is raised.
my_list = [1, 2, 3]
for i in my_list:
    print(i)

# In summary, an iterator is an object that allows you to iterate over a series of values, such as the elements of a list or the characters in a string. 
# It provides a convenient and efficient way to access the elements of a collection one at a time, rather than loading the entire collection into memory at once.